# coding: utf-8

"""
    webstatus.dev API

    A tool to monitor and track the status of all Web Platform features across dimensions that are related to availability and implementation quality across browsers, and adoption by web developers. 

    The version of the OpenAPI document: 0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import date
from pydantic import Field, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from webstatus_openapi.models.browser_release_feature_metrics_page import BrowserReleaseFeatureMetricsPage
from webstatus_openapi.models.chromium_daily_stats_page import ChromiumDailyStatsPage
from webstatus_openapi.models.feature import Feature
from webstatus_openapi.models.feature_metadata import FeatureMetadata
from webstatus_openapi.models.feature_page import FeaturePage
from webstatus_openapi.models.saved_search_page import SavedSearchPage
from webstatus_openapi.models.saved_search_response import SavedSearchResponse
from webstatus_openapi.models.supported_browsers import SupportedBrowsers
from webstatus_openapi.models.wpt_metric_view import WPTMetricView
from webstatus_openapi.models.wpt_run_metrics_page import WPTRunMetricsPage

from webstatus_openapi.api_client import ApiClient, RequestSerialized
from webstatus_openapi.api_response import ApiResponse
from webstatus_openapi.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_feature(
        self,
        feature_id: Annotated[StrictStr, Field(description="Feature ID")],
        wpt_metric_view: Optional[WPTMetricView] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Feature:
        """Get Feature


        :param feature_id: Feature ID (required)
        :type feature_id: str
        :param wpt_metric_view:
        :type wpt_metric_view: WPTMetricView
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_feature_serialize(
            feature_id=feature_id,
            wpt_metric_view=wpt_metric_view,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Feature",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_feature_with_http_info(
        self,
        feature_id: Annotated[StrictStr, Field(description="Feature ID")],
        wpt_metric_view: Optional[WPTMetricView] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Feature]:
        """Get Feature


        :param feature_id: Feature ID (required)
        :type feature_id: str
        :param wpt_metric_view:
        :type wpt_metric_view: WPTMetricView
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_feature_serialize(
            feature_id=feature_id,
            wpt_metric_view=wpt_metric_view,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Feature",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_feature_without_preload_content(
        self,
        feature_id: Annotated[StrictStr, Field(description="Feature ID")],
        wpt_metric_view: Optional[WPTMetricView] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Feature


        :param feature_id: Feature ID (required)
        :type feature_id: str
        :param wpt_metric_view:
        :type wpt_metric_view: WPTMetricView
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_feature_serialize(
            feature_id=feature_id,
            wpt_metric_view=wpt_metric_view,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Feature",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_feature_serialize(
        self,
        feature_id,
        wpt_metric_view,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if feature_id is not None:
            _path_params['feature_id'] = feature_id
        # process the query parameters
        if wpt_metric_view is not None:
            
            _query_params.append(('wpt_metric_view', wpt_metric_view.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/features/{feature_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_feature_metadata(
        self,
        feature_id: Annotated[StrictStr, Field(description="Feature ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FeatureMetadata:
        """Get metadata for a given feature from github.com/web-platform-dx/web-features


        :param feature_id: Feature ID (required)
        :type feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_feature_metadata_serialize(
            feature_id=feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureMetadata",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_feature_metadata_with_http_info(
        self,
        feature_id: Annotated[StrictStr, Field(description="Feature ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FeatureMetadata]:
        """Get metadata for a given feature from github.com/web-platform-dx/web-features


        :param feature_id: Feature ID (required)
        :type feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_feature_metadata_serialize(
            feature_id=feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureMetadata",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_feature_metadata_without_preload_content(
        self,
        feature_id: Annotated[StrictStr, Field(description="Feature ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get metadata for a given feature from github.com/web-platform-dx/web-features


        :param feature_id: Feature ID (required)
        :type feature_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_feature_metadata_serialize(
            feature_id=feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureMetadata",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_feature_metadata_serialize(
        self,
        feature_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if feature_id is not None:
            _path_params['feature_id'] = feature_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/features/{feature_id}/feature-metadata',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_saved_search(
        self,
        search_id: Annotated[StrictStr, Field(description="Saved Search ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SavedSearchResponse:
        """Get saved search


        :param search_id: Saved Search ID (required)
        :type search_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_saved_search_serialize(
            search_id=search_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SavedSearchResponse",
            '404': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_saved_search_with_http_info(
        self,
        search_id: Annotated[StrictStr, Field(description="Saved Search ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SavedSearchResponse]:
        """Get saved search


        :param search_id: Saved Search ID (required)
        :type search_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_saved_search_serialize(
            search_id=search_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SavedSearchResponse",
            '404': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_saved_search_without_preload_content(
        self,
        search_id: Annotated[StrictStr, Field(description="Saved Search ID")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get saved search


        :param search_id: Saved Search ID (required)
        :type search_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_saved_search_serialize(
            search_id=search_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SavedSearchResponse",
            '404': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_saved_search_serialize(
        self,
        search_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if search_id is not None:
            _path_params['search_id'] = search_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/saved-searches/{search_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_aggregated_feature_support(
        self,
        browser: Annotated[SupportedBrowsers, Field(description="Browser name")],
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BrowserReleaseFeatureMetricsPage:
        """Returns the count of features supported for a specified browser over time. The timestamps for the individual metrics represent the releases of the specified browser. 


        :param browser: Browser name (required)
        :type browser: SupportedBrowsers
        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_aggregated_feature_support_serialize(
            browser=browser,
            start_at=start_at,
            end_at=end_at,
            page_token=page_token,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BrowserReleaseFeatureMetricsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_aggregated_feature_support_with_http_info(
        self,
        browser: Annotated[SupportedBrowsers, Field(description="Browser name")],
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BrowserReleaseFeatureMetricsPage]:
        """Returns the count of features supported for a specified browser over time. The timestamps for the individual metrics represent the releases of the specified browser. 


        :param browser: Browser name (required)
        :type browser: SupportedBrowsers
        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_aggregated_feature_support_serialize(
            browser=browser,
            start_at=start_at,
            end_at=end_at,
            page_token=page_token,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BrowserReleaseFeatureMetricsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_aggregated_feature_support_without_preload_content(
        self,
        browser: Annotated[SupportedBrowsers, Field(description="Browser name")],
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns the count of features supported for a specified browser over time. The timestamps for the individual metrics represent the releases of the specified browser. 


        :param browser: Browser name (required)
        :type browser: SupportedBrowsers
        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_aggregated_feature_support_serialize(
            browser=browser,
            start_at=start_at,
            end_at=end_at,
            page_token=page_token,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BrowserReleaseFeatureMetricsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_aggregated_feature_support_serialize(
        self,
        browser,
        start_at,
        end_at,
        page_token,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if browser is not None:
            _path_params['browser'] = browser.value
        # process the query parameters
        if start_at is not None:
            if isinstance(start_at, date):
                _query_params.append(
                    (
                        'startAt',
                        start_at.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('startAt', start_at))
            
        if end_at is not None:
            if isinstance(end_at, date):
                _query_params.append(
                    (
                        'endAt',
                        end_at.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('endAt', end_at))
            
        if page_token is not None:
            
            _query_params.append(('page_token', page_token))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/stats/features/browsers/{browser}/feature_counts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_aggregated_wpt_metrics(
        self,
        browser: Annotated[SupportedBrowsers, Field(description="Browser name")],
        channel: Annotated[StrictStr, Field(description="Browser name")],
        metric_view: Annotated[WPTMetricView, Field(description="Specified metric view of the WPT data.")],
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        feature_id: Annotated[Optional[List[StrictStr]], Field(description="A list of feature IDs to filter results. TThe list is provided by specifying repeating query parameters. Example: ?featureId=id1&featureId=id2 ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WPTRunMetricsPage:
        """Gets aggregated WPT test counts for a specified browser and channel. Optionally filter by feature IDs. 


        :param browser: Browser name (required)
        :type browser: SupportedBrowsers
        :param channel: Browser name (required)
        :type channel: str
        :param metric_view: Specified metric view of the WPT data. (required)
        :type metric_view: WPTMetricView
        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param feature_id: A list of feature IDs to filter results. TThe list is provided by specifying repeating query parameters. Example: ?featureId=id1&featureId=id2 
        :type feature_id: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_aggregated_wpt_metrics_serialize(
            browser=browser,
            channel=channel,
            metric_view=metric_view,
            start_at=start_at,
            end_at=end_at,
            page_token=page_token,
            page_size=page_size,
            feature_id=feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WPTRunMetricsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_aggregated_wpt_metrics_with_http_info(
        self,
        browser: Annotated[SupportedBrowsers, Field(description="Browser name")],
        channel: Annotated[StrictStr, Field(description="Browser name")],
        metric_view: Annotated[WPTMetricView, Field(description="Specified metric view of the WPT data.")],
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        feature_id: Annotated[Optional[List[StrictStr]], Field(description="A list of feature IDs to filter results. TThe list is provided by specifying repeating query parameters. Example: ?featureId=id1&featureId=id2 ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WPTRunMetricsPage]:
        """Gets aggregated WPT test counts for a specified browser and channel. Optionally filter by feature IDs. 


        :param browser: Browser name (required)
        :type browser: SupportedBrowsers
        :param channel: Browser name (required)
        :type channel: str
        :param metric_view: Specified metric view of the WPT data. (required)
        :type metric_view: WPTMetricView
        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param feature_id: A list of feature IDs to filter results. TThe list is provided by specifying repeating query parameters. Example: ?featureId=id1&featureId=id2 
        :type feature_id: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_aggregated_wpt_metrics_serialize(
            browser=browser,
            channel=channel,
            metric_view=metric_view,
            start_at=start_at,
            end_at=end_at,
            page_token=page_token,
            page_size=page_size,
            feature_id=feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WPTRunMetricsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_aggregated_wpt_metrics_without_preload_content(
        self,
        browser: Annotated[SupportedBrowsers, Field(description="Browser name")],
        channel: Annotated[StrictStr, Field(description="Browser name")],
        metric_view: Annotated[WPTMetricView, Field(description="Specified metric view of the WPT data.")],
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        feature_id: Annotated[Optional[List[StrictStr]], Field(description="A list of feature IDs to filter results. TThe list is provided by specifying repeating query parameters. Example: ?featureId=id1&featureId=id2 ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets aggregated WPT test counts for a specified browser and channel. Optionally filter by feature IDs. 


        :param browser: Browser name (required)
        :type browser: SupportedBrowsers
        :param channel: Browser name (required)
        :type channel: str
        :param metric_view: Specified metric view of the WPT data. (required)
        :type metric_view: WPTMetricView
        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param feature_id: A list of feature IDs to filter results. TThe list is provided by specifying repeating query parameters. Example: ?featureId=id1&featureId=id2 
        :type feature_id: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_aggregated_wpt_metrics_serialize(
            browser=browser,
            channel=channel,
            metric_view=metric_view,
            start_at=start_at,
            end_at=end_at,
            page_token=page_token,
            page_size=page_size,
            feature_id=feature_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WPTRunMetricsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_aggregated_wpt_metrics_serialize(
        self,
        browser,
        channel,
        metric_view,
        start_at,
        end_at,
        page_token,
        page_size,
        feature_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'featureId': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if browser is not None:
            _path_params['browser'] = browser.value
        if channel is not None:
            _path_params['channel'] = channel
        if metric_view is not None:
            _path_params['metric_view'] = metric_view.value
        # process the query parameters
        if start_at is not None:
            if isinstance(start_at, date):
                _query_params.append(
                    (
                        'startAt',
                        start_at.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('startAt', start_at))
            
        if end_at is not None:
            if isinstance(end_at, date):
                _query_params.append(
                    (
                        'endAt',
                        end_at.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('endAt', end_at))
            
        if page_token is not None:
            
            _query_params.append(('page_token', page_token))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        if feature_id is not None:
            
            _query_params.append(('featureId', feature_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/stats/wpt/browsers/{browser}/channels/{channel}/{metric_view}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_chromium_daily_usage_stats(
        self,
        feature_id: Annotated[StrictStr, Field(description="Feature ID")],
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChromiumDailyStatsPage:
        """Get Chromium daily usage metrics for a given feature


        :param feature_id: Feature ID (required)
        :type feature_id: str
        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_chromium_daily_usage_stats_serialize(
            feature_id=feature_id,
            start_at=start_at,
            end_at=end_at,
            page_token=page_token,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChromiumDailyStatsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_chromium_daily_usage_stats_with_http_info(
        self,
        feature_id: Annotated[StrictStr, Field(description="Feature ID")],
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChromiumDailyStatsPage]:
        """Get Chromium daily usage metrics for a given feature


        :param feature_id: Feature ID (required)
        :type feature_id: str
        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_chromium_daily_usage_stats_serialize(
            feature_id=feature_id,
            start_at=start_at,
            end_at=end_at,
            page_token=page_token,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChromiumDailyStatsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_chromium_daily_usage_stats_without_preload_content(
        self,
        feature_id: Annotated[StrictStr, Field(description="Feature ID")],
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Chromium daily usage metrics for a given feature


        :param feature_id: Feature ID (required)
        :type feature_id: str
        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_chromium_daily_usage_stats_serialize(
            feature_id=feature_id,
            start_at=start_at,
            end_at=end_at,
            page_token=page_token,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChromiumDailyStatsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_chromium_daily_usage_stats_serialize(
        self,
        feature_id,
        start_at,
        end_at,
        page_token,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if feature_id is not None:
            _path_params['feature_id'] = feature_id
        # process the query parameters
        if start_at is not None:
            if isinstance(start_at, date):
                _query_params.append(
                    (
                        'startAt',
                        start_at.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('startAt', start_at))
            
        if end_at is not None:
            if isinstance(end_at, date):
                _query_params.append(
                    (
                        'endAt',
                        end_at.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('endAt', end_at))
            
        if page_token is not None:
            
            _query_params.append(('page_token', page_token))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/features/{feature_id}/stats/usage/chromium/daily_stats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_feature_wpt_metrics(
        self,
        feature_id: Annotated[StrictStr, Field(description="Feature ID")],
        browser: Annotated[SupportedBrowsers, Field(description="Browser name")],
        channel: Annotated[StrictStr, Field(description="Browser name")],
        metric_view: Annotated[WPTMetricView, Field(description="Specified metric view of the WPT data.")],
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WPTRunMetricsPage:
        """Retrieve the wpt stats for a particular feature.


        :param feature_id: Feature ID (required)
        :type feature_id: str
        :param browser: Browser name (required)
        :type browser: SupportedBrowsers
        :param channel: Browser name (required)
        :type channel: str
        :param metric_view: Specified metric view of the WPT data. (required)
        :type metric_view: WPTMetricView
        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_feature_wpt_metrics_serialize(
            feature_id=feature_id,
            browser=browser,
            channel=channel,
            metric_view=metric_view,
            start_at=start_at,
            end_at=end_at,
            page_token=page_token,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WPTRunMetricsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_feature_wpt_metrics_with_http_info(
        self,
        feature_id: Annotated[StrictStr, Field(description="Feature ID")],
        browser: Annotated[SupportedBrowsers, Field(description="Browser name")],
        channel: Annotated[StrictStr, Field(description="Browser name")],
        metric_view: Annotated[WPTMetricView, Field(description="Specified metric view of the WPT data.")],
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WPTRunMetricsPage]:
        """Retrieve the wpt stats for a particular feature.


        :param feature_id: Feature ID (required)
        :type feature_id: str
        :param browser: Browser name (required)
        :type browser: SupportedBrowsers
        :param channel: Browser name (required)
        :type channel: str
        :param metric_view: Specified metric view of the WPT data. (required)
        :type metric_view: WPTMetricView
        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_feature_wpt_metrics_serialize(
            feature_id=feature_id,
            browser=browser,
            channel=channel,
            metric_view=metric_view,
            start_at=start_at,
            end_at=end_at,
            page_token=page_token,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WPTRunMetricsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_feature_wpt_metrics_without_preload_content(
        self,
        feature_id: Annotated[StrictStr, Field(description="Feature ID")],
        browser: Annotated[SupportedBrowsers, Field(description="Browser name")],
        channel: Annotated[StrictStr, Field(description="Browser name")],
        metric_view: Annotated[WPTMetricView, Field(description="Specified metric view of the WPT data.")],
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieve the wpt stats for a particular feature.


        :param feature_id: Feature ID (required)
        :type feature_id: str
        :param browser: Browser name (required)
        :type browser: SupportedBrowsers
        :param channel: Browser name (required)
        :type channel: str
        :param metric_view: Specified metric view of the WPT data. (required)
        :type metric_view: WPTMetricView
        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_feature_wpt_metrics_serialize(
            feature_id=feature_id,
            browser=browser,
            channel=channel,
            metric_view=metric_view,
            start_at=start_at,
            end_at=end_at,
            page_token=page_token,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WPTRunMetricsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_feature_wpt_metrics_serialize(
        self,
        feature_id,
        browser,
        channel,
        metric_view,
        start_at,
        end_at,
        page_token,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if feature_id is not None:
            _path_params['feature_id'] = feature_id
        if browser is not None:
            _path_params['browser'] = browser.value
        if channel is not None:
            _path_params['channel'] = channel
        if metric_view is not None:
            _path_params['metric_view'] = metric_view.value
        # process the query parameters
        if start_at is not None:
            if isinstance(start_at, date):
                _query_params.append(
                    (
                        'startAt',
                        start_at.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('startAt', start_at))
            
        if end_at is not None:
            if isinstance(end_at, date):
                _query_params.append(
                    (
                        'endAt',
                        end_at.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('endAt', end_at))
            
        if page_token is not None:
            
            _query_params.append(('page_token', page_token))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/features/{feature_id}/stats/wpt/browsers/{browser}/channels/{channel}/{metric_view}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_features(
        self,
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        wpt_metric_view: Optional[WPTMetricView] = None,
        q: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="A query string to represent the filters to apply the datastore while searching. The query must follow the ANTLR grammar. Please read the query readme at antlr/FeatureSearch.md. The query must be url safe. ")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Field to sort by, with 'asc' for ascending and 'desc' for descending order. Defaults to sorting by 'name' in ascending order (e.g., 'name_asc'). ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FeaturePage:
        """List features


        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param wpt_metric_view:
        :type wpt_metric_view: WPTMetricView
        :param q: A query string to represent the filters to apply the datastore while searching. The query must follow the ANTLR grammar. Please read the query readme at antlr/FeatureSearch.md. The query must be url safe. 
        :type q: str
        :param sort: Field to sort by, with 'asc' for ascending and 'desc' for descending order. Defaults to sorting by 'name' in ascending order (e.g., 'name_asc'). 
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_features_serialize(
            page_token=page_token,
            page_size=page_size,
            wpt_metric_view=wpt_metric_view,
            q=q,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeaturePage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_features_with_http_info(
        self,
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        wpt_metric_view: Optional[WPTMetricView] = None,
        q: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="A query string to represent the filters to apply the datastore while searching. The query must follow the ANTLR grammar. Please read the query readme at antlr/FeatureSearch.md. The query must be url safe. ")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Field to sort by, with 'asc' for ascending and 'desc' for descending order. Defaults to sorting by 'name' in ascending order (e.g., 'name_asc'). ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FeaturePage]:
        """List features


        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param wpt_metric_view:
        :type wpt_metric_view: WPTMetricView
        :param q: A query string to represent the filters to apply the datastore while searching. The query must follow the ANTLR grammar. Please read the query readme at antlr/FeatureSearch.md. The query must be url safe. 
        :type q: str
        :param sort: Field to sort by, with 'asc' for ascending and 'desc' for descending order. Defaults to sorting by 'name' in ascending order (e.g., 'name_asc'). 
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_features_serialize(
            page_token=page_token,
            page_size=page_size,
            wpt_metric_view=wpt_metric_view,
            q=q,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeaturePage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_features_without_preload_content(
        self,
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        wpt_metric_view: Optional[WPTMetricView] = None,
        q: Annotated[Optional[Annotated[str, Field(min_length=1, strict=True)]], Field(description="A query string to represent the filters to apply the datastore while searching. The query must follow the ANTLR grammar. Please read the query readme at antlr/FeatureSearch.md. The query must be url safe. ")] = None,
        sort: Annotated[Optional[StrictStr], Field(description="Field to sort by, with 'asc' for ascending and 'desc' for descending order. Defaults to sorting by 'name' in ascending order (e.g., 'name_asc'). ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List features


        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param wpt_metric_view:
        :type wpt_metric_view: WPTMetricView
        :param q: A query string to represent the filters to apply the datastore while searching. The query must follow the ANTLR grammar. Please read the query readme at antlr/FeatureSearch.md. The query must be url safe. 
        :type q: str
        :param sort: Field to sort by, with 'asc' for ascending and 'desc' for descending order. Defaults to sorting by 'name' in ascending order (e.g., 'name_asc'). 
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_features_serialize(
            page_token=page_token,
            page_size=page_size,
            wpt_metric_view=wpt_metric_view,
            q=q,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeaturePage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_features_serialize(
        self,
        page_token,
        page_size,
        wpt_metric_view,
        q,
        sort,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if page_token is not None:
            
            _query_params.append(('page_token', page_token))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        if wpt_metric_view is not None:
            
            _query_params.append(('wpt_metric_view', wpt_metric_view.value))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/features',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_missing_one_implemenation_counts(
        self,
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        browser: Annotated[SupportedBrowsers, Field(description="Browser name")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BrowserReleaseFeatureMetricsPage:
        """Returns the count of features that are supported by all of the specified comparison browsers but not supported by the specified target browser, as of each browser's (target browser or comparison browser) release date. 


        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param browser: Browser name (required)
        :type browser: SupportedBrowsers
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_missing_one_implemenation_counts_serialize(
            start_at=start_at,
            end_at=end_at,
            browser=browser,
            page_token=page_token,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BrowserReleaseFeatureMetricsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_missing_one_implemenation_counts_with_http_info(
        self,
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        browser: Annotated[SupportedBrowsers, Field(description="Browser name")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BrowserReleaseFeatureMetricsPage]:
        """Returns the count of features that are supported by all of the specified comparison browsers but not supported by the specified target browser, as of each browser's (target browser or comparison browser) release date. 


        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param browser: Browser name (required)
        :type browser: SupportedBrowsers
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_missing_one_implemenation_counts_serialize(
            start_at=start_at,
            end_at=end_at,
            browser=browser,
            page_token=page_token,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BrowserReleaseFeatureMetricsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_missing_one_implemenation_counts_without_preload_content(
        self,
        start_at: Annotated[date, Field(description="Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive.")],
        end_at: Annotated[date, Field(description="End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive.")],
        browser: Annotated[SupportedBrowsers, Field(description="Browser name")],
        page_token: Annotated[Optional[StrictStr], Field(description="Pagination token")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of results to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Returns the count of features that are supported by all of the specified comparison browsers but not supported by the specified target browser, as of each browser's (target browser or comparison browser) release date. 


        :param start_at: Start date (RFC 3339, section 5.6, for example, 2017-07-21). The date is inclusive. (required)
        :type start_at: date
        :param end_at: End date (RFC 3339, section 5.6, for example, 2017-07-21). The date is exclusive. (required)
        :type end_at: date
        :param browser: Browser name (required)
        :type browser: SupportedBrowsers
        :param page_token: Pagination token
        :type page_token: str
        :param page_size: Number of results to return
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_missing_one_implemenation_counts_serialize(
            start_at=start_at,
            end_at=end_at,
            browser=browser,
            page_token=page_token,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BrowserReleaseFeatureMetricsPage",
            '400': "BasicErrorModel",
            '404': "BasicErrorModel",
            '429': "BasicErrorModel",
            '500': "BasicErrorModel",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_missing_one_implemenation_counts_serialize(
        self,
        start_at,
        end_at,
        browser,
        page_token,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if browser is not None:
            _path_params['browser'] = browser.value
        # process the query parameters
        if start_at is not None:
            if isinstance(start_at, date):
                _query_params.append(
                    (
                        'startAt',
                        start_at.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('startAt', start_at))
            
        if end_at is not None:
            if isinstance(end_at, date):
                _query_params.append(
                    (
                        'endAt',
                        end_at.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('endAt', end_at))
            
        if page_token is not None:
            
            _query_params.append(('page_token', page_token))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/stats/features/browsers/{browser}/missing_one_implementation_counts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_saved_searches(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SavedSearchPage:
        """List saved searches


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_saved_searches_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SavedSearchPage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_saved_searches_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SavedSearchPage]:
        """List saved searches


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_saved_searches_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SavedSearchPage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_saved_searches_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List saved searches


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_saved_searches_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SavedSearchPage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_saved_searches_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/saved-searches',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


